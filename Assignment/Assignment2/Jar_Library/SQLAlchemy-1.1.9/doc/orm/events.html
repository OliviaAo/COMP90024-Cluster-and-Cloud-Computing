<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        
        <title>
            
    
    ORM Events
 &mdash;
    SQLAlchemy 1.1 Documentation

        </title>

        
            <!-- begin iterate through SQLA + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through SQLA + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 1.1 Documentation" href="../index.html" />
        <link rel="up" title="Events and Internals" href="extending.html" />
        <link rel="next" title="ORM Internals" href="internals.html" />
        <link rel="prev" title="Events and Internals" href="extending.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">1.1.9</span>
        | Release Date: April 4, 2017

    </div>

    <h1>SQLAlchemy 1.1 Documentation</h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">


        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 1.1 Documentation</a></h3>

            <p id="sidebar-topnav">
                <a href="../contents.html">Contents</a> |
                <a href="../genindex.html">Index</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy ORM">SQLAlchemy ORM</a>
        </h3>

        <ul>
<li><span class="link-container first"><a class="reference external" href="tutorial.html">Object Relational Tutorial</a></span></li>
<li><span class="link-container first"><a class="reference external" href="mapper_config.html">Mapper Configuration</a></span></li>
<li><span class="link-container first"><a class="reference external" href="relationships.html">Relationship Configuration</a></span></li>
<li><span class="link-container first"><a class="reference external" href="loading_objects.html">Loading Objects</a></span></li>
<li><span class="link-container first"><a class="reference external" href="session.html">Using the Session</a></span></li>
<li><span class="link-container first"><a class="reference external" href="extending.html">Events and Internals</a></span><ul>
<li class="selected"><span class="link-container first"><strong>ORM Events</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container first"><a class="reference external" href="#attribute-events">Attribute Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#mapper-events">Mapper Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#instance-events">Instance Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#session-events">Session Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#query-events">Query Events</a></span></li>
<li><span class="link-container first"><a class="reference external" href="#module-sqlalchemy.orm.instrumentation">Instrumentation Events</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="internals.html">ORM Internals</a></span></li>
<li><span class="link-container first"><a class="reference external" href="exceptions.html">ORM Exceptions</a></span></li>
<li><span class="link-container first"><a class="reference external" href="deprecated.html">Deprecated ORM Event Interfaces</a></span></li>
</ul>
</li>
<li><span class="link-container first"><a class="reference external" href="extensions/index.html">ORM Extensions</a></span></li>
<li><span class="link-container first"><a class="reference external" href="examples.html">ORM Examples</a></span></li>
</ul>



        </div>

        </div>

    </div>

    

    <div id="docs-body" class="withsidebar" >
        
<div class="section" id="orm-events">
<span id="orm-event-toplevel"></span><h1>ORM Events<a class="headerlink" href="#orm-events" title="Permalink to this headline">¶</a></h1>
<p>The ORM includes a wide variety of hooks available for subscription.</p>
<p>For an introduction to the most commonly used ORM events, see the section
<a class="reference internal" href="session_events.html"><span class="std std-ref">Tracking Object and Session Changes with Events</span></a>.   The event system in general is discussed
at <a class="reference internal" href="../core/event.html"><span class="std std-ref">Events</span></a>.  Non-ORM events such as those regarding connections
and low-level statement execution are described in <a class="reference internal" href="../core/events.html"><span class="std std-ref">Core Events</span></a>.</p>
<div class="section" id="attribute-events">
<h2>Attribute Events<a class="headerlink" href="#attribute-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.AttributeEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">AttributeEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events for object attributes.</p>
<p>These are typically defined on the class-bound descriptor for the
target class.</p>
<p>e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_append_listener</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;received append event for target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">target</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">MyClass</span><span class="o">.</span><span class="n">collection</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="n">my_append_listener</span><span class="p">)</span></pre></div>
</div>
<p>Listeners have the option to return a possibly modified version
of the value, when the <code class="docutils literal"><span class="pre">retval=True</span></code> flag is passed
to <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_phone</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">oldvalue</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s2">&quot;Strip non-numeric characters from a phone number&quot;</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\D&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># setup listener on UserContact.phone attribute, instructing</span>
<span class="c1"># it to use the return value</span>
<span class="n">listen</span><span class="p">(</span><span class="n">UserContact</span><span class="o">.</span><span class="n">phone</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="n">validate_phone</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></pre></div>
</div>
<p>A validation function like the above can also raise an exception
such as <code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> to halt the operation.</p>
<p>Several modifiers are available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.active_history"></span><strong>active_history=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.active_history">¶</a> &#8211; When True, indicates that the
&#8220;set&#8221; event would like to receive the &#8220;old&#8221; value being
replaced unconditionally, even if this requires firing off
database loads. Note that <code class="docutils literal"><span class="pre">active_history</span></code> can also be
set directly via <a class="reference internal" href="mapping_columns.html#sqlalchemy.orm.column_property" title="sqlalchemy.orm.column_property"><code class="xref py py-func docutils literal"><span class="pre">column_property()</span></code></a> and
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal"><span class="pre">relationship()</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.propagate">¶</a> &#8211; When True, the listener function will
be established not just for the class attribute given, but
for attributes of the same name on all current subclasses
of that class, as well as all future subclasses of that
class, using an additional listener that listens for
instrumentation events.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument to the
event will be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.params.retval"></span><strong>retval=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.params.retval">¶</a> &#8211; when True, the user-defined event
listening must return the &#8220;value&#8221; argument from the
function.  This gives the listening function the opportunity
to change the value that is ultimately used for a &#8220;set&#8221;
or &#8220;append&#8221; event.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a collection append event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_append</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;append&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.value">¶</a> &#8211; the value being appended.  If this listener
is registered with <code class="docutils literal"><span class="pre">retval=True</span></code>, the listener
function must return this value, or a new value which
replaces it.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.append.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.append.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">if the event was registered with <code class="docutils literal"><span class="pre">retval=True</span></code>,
the given value, or a new effective value, should be returned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.dispose_collection">
<code class="descname">dispose_collection</code><span class="sig-paren">(</span><em>target</em>, <em>collection</em>, <em>collection_adpater</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a &#8216;collection dispose&#8217; event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;dispose_collection&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_dispose_collection</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">collection_adpater</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;dispose_collection&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is triggered for a collection-based attribute when
a collection is replaced, that is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

<span class="n">u1</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">]</span>  <span class="c1"># &lt;- old collection is disposed</span></pre></div>
</div>
<p>The mechanics of the event will typically include that the given
collection is empty, even if it stored objects while being replaced.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0: </span>the <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="sqlalchemy.orm.events.AttributeEvents.init_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.init_collection()</span></code></a>
and <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="sqlalchemy.orm.events.AttributeEvents.dispose_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.dispose_collection()</span></code></a> events supersede
the <code class="xref py py-class docutils literal"><span class="pre">collection.linker</span></code> hook.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.init_collection">
<code class="descname">init_collection</code><span class="sig-paren">(</span><em>target</em>, <em>collection</em>, <em>collection_adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a &#8216;collection init&#8217; event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;init_collection&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init_collection</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collection</span><span class="p">,</span> <span class="n">collection_adapter</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;init_collection&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is triggered for a collection-based attribute, when
the initial &#8220;empty collection&#8221; is first generated for a blank
attribute, as well as for when the collection is replaced with
a new one, such as via a set event.</p>
<p>E.g., given that <code class="docutils literal"><span class="pre">User.addresses</span></code> is a relationship-based
collection, the event is triggered here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
<span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>  <span class="c1">#  &lt;- new collection</span></pre></div>
</div>
<p>and also during replace operations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span> <span class="o">=</span> <span class="p">[</span><span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">]</span>  <span class="c1">#  &lt;- new collection</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection"></span><strong>collection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection">¶</a> &#8211; the new collection.  This will always be generated
from what was specified as
<a class="reference internal" href="internals.html#sqlalchemy.orm.properties.RelationshipProperty.params.collection_class" title="sqlalchemy.orm.properties.RelationshipProperty"><code class="xref py py-paramref docutils literal"><span class="pre">RelationshipProperty.collection_class</span></code></a>, and will always
be empty.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection_adpater"></span><strong>collection_adpater</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection.params.collection_adpater">¶</a> &#8211; the <a class="reference internal" href="collections.html#sqlalchemy.orm.collections.CollectionAdapter" title="sqlalchemy.orm.collections.CollectionAdapter"><code class="xref py py-class docutils literal"><span class="pre">CollectionAdapter</span></code></a> that will
mediate internal access to the collection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0: </span>the <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_collection" title="sqlalchemy.orm.events.AttributeEvents.init_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.init_collection()</span></code></a>
and <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.dispose_collection" title="sqlalchemy.orm.events.AttributeEvents.dispose_collection"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.dispose_collection()</span></code></a> events supersede
the <code class="xref py py-class docutils literal"><span class="pre">collection.linker</span></code> hook.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.init_scalar">
<code class="descname">init_scalar</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>dict_</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.init_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a scalar &#8220;init&#8221; event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;init_scalar&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init_scalar</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dict_</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;init_scalar&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked when an uninitialized, unpersisted scalar
attribute is accessed.  A value of <code class="docutils literal"><span class="pre">None</span></code> is typically returned
in this case; no changes are made to the object&#8217;s state.</p>
<p>The event handler can alter this behavior in two ways.
One is that a value other than <code class="docutils literal"><span class="pre">None</span></code> may be returned.  The other
is that the value may be established as part of the object&#8217;s state,
which will also have the effect that it is persisted.</p>
<p>Typical use is to establish a specific default value of an attribute
upon access:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SOME_CONSTANT</span> <span class="o">=</span> <span class="mf">3.1415926</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span>
    <span class="n">MyClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s2">&quot;init_scalar&quot;</span><span class="p">,</span>
    <span class="n">retval</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_init_some_attribute</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dict_</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">dict_</span><span class="p">[</span><span class="s1">&#39;some_attribute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SOME_CONSTANT</span>
    <span class="k">return</span> <span class="n">SOME_CONSTANT</span></pre></div>
</div>
<p>Above, we initialize the attribute <code class="docutils literal"><span class="pre">MyClass.some_attribute</span></code> to the
value of <code class="docutils literal"><span class="pre">SOME_CONSTANT</span></code>.   The above code includes the following
features:</p>
<ul class="simple">
<li>By setting the value <code class="docutils literal"><span class="pre">SOME_CONSTANT</span></code> in the given <code class="docutils literal"><span class="pre">dict_</span></code>,
we indicate that the value is to be persisted to the database.
<strong>The given value is only persisted to the database if we
explicitly associate it with the object</strong>.  The <code class="docutils literal"><span class="pre">dict_</span></code> given
is the <code class="docutils literal"><span class="pre">__dict__</span></code> element of the mapped object, assuming the
default attribute instrumentation system is in place.</li>
<li>By establishing the <code class="docutils literal"><span class="pre">retval=True</span></code> flag, the value we return
from the function will be returned by the attribute getter.
Without this flag, the event is assumed to be a passive observer
and the return value of our function is ignored.</li>
<li>The <code class="docutils literal"><span class="pre">propagate=True</span></code> flag is significant if the mapped class
includes inheriting subclasses, which would also make use of this
event listener.  Without this flag, an inheriting subclass will
not use our event handler.</li>
</ul>
<p>When we establish the value in the given dictionary, the value will
be used in the INSERT statement established by the unit of work.
Normally, the default returned value of <code class="docutils literal"><span class="pre">None</span></code> is not established as
part of the object, to avoid the issue of mutations occurring to the
object in response to a normally passive &#8220;get&#8221; operation, and also
sidesteps the issue of whether or not the <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set" title="sqlalchemy.orm.events.AttributeEvents.set"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.set()</span></code></a>
event should be awkwardly fired off during an attribute access
operation.  This does not impact the INSERT operation since the
<code class="docutils literal"><span class="pre">None</span></code> value matches the value of <code class="docutils literal"><span class="pre">NULL</span></code> that goes into the
database in any case; note that <code class="docutils literal"><span class="pre">None</span></code> is skipped during the INSERT
to ensure that column and SQL-level default functions can fire off.</p>
<p>The attribute set event <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set" title="sqlalchemy.orm.events.AttributeEvents.set"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.set()</span></code></a> as well as the
related validation feature provided by <a class="reference internal" href="mapped_attributes.html#sqlalchemy.orm.validates" title="sqlalchemy.orm.validates"><code class="xref py py-obj docutils literal"><span class="pre">orm.validates</span></code></a> is
<strong>not</strong> invoked when we apply our value to the given <code class="docutils literal"><span class="pre">dict_</span></code>.  To
have these events to invoke in response to our newly generated
value, apply the value to the given object as a normal attribute
set operation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SOME_CONSTANT</span> <span class="o">=</span> <span class="mf">3.1415926</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span>
    <span class="n">MyClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s2">&quot;init_scalar&quot;</span><span class="p">,</span>
    <span class="n">retval</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_init_some_attribute</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dict_</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="c1"># will also fire off attribute set events</span>
    <span class="n">target</span><span class="o">.</span><span class="n">some_attribute</span> <span class="o">=</span> <span class="n">SOME_CONSTANT</span>
    <span class="k">return</span> <span class="n">SOME_CONSTANT</span></pre></div>
</div>
<p>When multiple listeners are set up, the generation of the value
is &#8220;chained&#8221; from one listener to the next by passing the value
returned by the previous listener that specifies <code class="docutils literal"><span class="pre">retval=True</span></code>
as the <code class="docutils literal"><span class="pre">value</span></code> argument of the next listener.</p>
<p>The <a class="reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_scalar" title="sqlalchemy.orm.events.AttributeEvents.init_scalar"><code class="xref py py-meth docutils literal"><span class="pre">AttributeEvents.init_scalar()</span></code></a> event may be used to
extract values from the default values and/or callables established on
mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal"><span class="pre">Column</span></code></a> objects.  See the &#8220;active column defaults&#8221;
example in <a class="reference internal" href="examples.html#examples-instrumentation"><span class="std std-ref">Attribute Instrumentation</span></a> for an example of this.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_scalar.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_scalar.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_scalar.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_scalar.params.value">¶</a> &#8211; the value that is to be returned before this event
listener were invoked.  This value begins as the value <code class="docutils literal"><span class="pre">None</span></code>,
however will be the return value of the previous event handler
function if multiple listeners are present.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.init_scalar.params.dict_"></span><strong>dict_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.init_scalar.params.dict_">¶</a> &#8211; the attribute dictionary of this mapped object.
This is normally the <code class="docutils literal"><span class="pre">__dict__</span></code> of the object, but in all cases
represents the destination that the attribute system uses to get
at the actual value of this attribute.  Placing the value in this
dictionary has the effect that the value will be used in the
INSERT statement generated by the unit of work.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="examples.html#examples-instrumentation"><span class="std std-ref">Attribute Instrumentation</span></a> - see the
<code class="docutils literal"><span class="pre">active_column_defaults.py</span></code> example.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a collection remove event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;remove&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_remove</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;remove&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.value">¶</a> &#8211; the value being removed.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.remove.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.remove.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is defined for this event.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.AttributeEvents.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>target</em>, <em>value</em>, <em>oldvalue</em>, <em>initiator</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.AttributeEvents.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a scalar set event.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_set</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">oldvalue</span><span class="p">,</span> <span class="n">initiator</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;set&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span>

<span class="c1"># named argument style (new in 0.9)</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="s1">&#39;set&#39;</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_set</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;set&#39; event&quot;</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.target">¶</a> &#8211; the object instance receiving the event.
If the listener is registered with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> object.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.value"></span><strong>value</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.value">¶</a> &#8211; the value being set.  If this listener
is registered with <code class="docutils literal"><span class="pre">retval=True</span></code>, the listener
function must return this value, or a new value which
replaces it.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.oldvalue"></span><strong>oldvalue</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.oldvalue">¶</a> &#8211; the previous value being replaced.  This
may also be the symbol <code class="docutils literal"><span class="pre">NEVER_SET</span></code> or <code class="docutils literal"><span class="pre">NO_VALUE</span></code>.
If the listener is registered with <code class="docutils literal"><span class="pre">active_history=True</span></code>,
the previous value of the attribute will be loaded from
the database if the existing value is currently unloaded
or expired.</li>
<li><span class="target" id="sqlalchemy.orm.events.AttributeEvents.set.params.initiator"></span><strong>initiator</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.AttributeEvents.set.params.initiator">¶</a> &#8211; <p>An instance of <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a>
representing the initiation of the event.  May be modified
from its original value by backref handlers in order to control
chained event propagation.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9.0: </span>the <code class="docutils literal"><span class="pre">initiator</span></code> argument is now
passed as a <a class="reference internal" href="internals.html#sqlalchemy.orm.attributes.Event" title="sqlalchemy.orm.attributes.Event"><code class="xref py py-class docutils literal"><span class="pre">attributes.Event</span></code></a> object, and may be
modified by backref handlers within a chain of backref-linked
events.</p>
</div>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">if the event was registered with <code class="docutils literal"><span class="pre">retval=True</span></code>,
the given value, or a new effective value, should be returned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mapper-events">
<h2>Mapper Events<a class="headerlink" href="#mapper-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.MapperEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">MapperEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to mappings.</p>
<p>e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_before_insert_listener</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="c1"># execute a stored procedure upon INSERT,</span>
    <span class="c1"># apply the value to the row to be inserted</span>
    <span class="n">target</span><span class="o">.</span><span class="n">calculated_value</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span>
                                <span class="s2">&quot;select my_special_function(</span><span class="si">%d</span><span class="s2">)&quot;</span>
                                <span class="o">%</span> <span class="n">target</span><span class="o">.</span><span class="n">special_number</span><span class="p">)</span>

<span class="c1"># associate the listener function with SomeClass,</span>
<span class="c1"># to execute during the &quot;before_insert&quot; hook</span>
<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span>
    <span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;before_insert&#39;</span><span class="p">,</span> <span class="n">my_before_insert_listener</span><span class="p">)</span></pre></div>
</div>
<p>Available targets include:</p>
<ul class="simple">
<li>mapped classes</li>
<li>unmapped superclasses of mapped or to-be-mapped classes
(using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag)</li>
<li><a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> objects</li>
<li>the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class itself and the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a>
function indicate listening for all mappers.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8.0: </span>mapper events can be associated with
unmapped superclasses of mapped classes.</p>
</div>
<p>Mapper events provide hooks into critical sections of the
mapper, including those related to object instrumentation,
object loading, and object persistence. In particular, the
persistence methods <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert" title="sqlalchemy.orm.events.MapperEvents.before_insert"><code class="xref py py-meth docutils literal"><span class="pre">before_insert()</span></code></a>,
and <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="sqlalchemy.orm.events.MapperEvents.before_update"><code class="xref py py-meth docutils literal"><span class="pre">before_update()</span></code></a> are popular
places to augment the state being persisted - however, these
methods operate with several significant restrictions. The
user is encouraged to evaluate the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> and
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_flush()</span></code></a> methods as more
flexible and user-friendly hooks in which to apply
additional database state during a flush.</p>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents" title="sqlalchemy.orm.events.MapperEvents"><code class="xref py py-class docutils literal"><span class="pre">MapperEvents</span></code></a>, several modifiers are
available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.propagate">¶</a> &#8211; When True, the event listener should
be applied to all inheriting mappers and/or the mappers of
inheriting classes, as well as any
mapper which is the target of this listener.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument passed
to applicable event listener functions will be the
instance&#8217;s <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.params.retval"></span><strong>retval=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.params.retval">¶</a> &#8211; <p>when True, the user-defined event function
must have a return value, the purpose of which is either to
control subsequent event propagation, or to otherwise alter
the operation in progress by the mapper.   Possible return
values are:</p>
<ul>
<li><code class="docutils literal"><span class="pre">sqlalchemy.orm.interfaces.EXT_CONTINUE</span></code> - continue event
processing normally.</li>
<li><code class="docutils literal"><span class="pre">sqlalchemy.orm.interfaces.EXT_STOP</span></code> - cancel all subsequent
event handlers in the chain.</li>
<li>other values - the return value specified by specific listeners.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_configured">
<code class="descname">after_configured</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after a series of mappers have been configured.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;after_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_configured</span><span class="p">():</span>
    <span class="s2">&quot;listen for the &#39;after_configured&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>The <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a> event is invoked
each time the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> function is
invoked, after the function has completed its work.
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.</p>
<p>Contrast this event to the <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a>
event, which is called on a per-mapper basis while the configuration
operation proceeds; unlike that event, when this event is invoked,
all cross-configurations (e.g. backrefs) will also have been made
available for any mappers that were pending.
Also constrast to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="sqlalchemy.orm.events.MapperEvents.before_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.before_configured()</span></code></a>,
which is invoked before the series of mappers has been configured.</p>
<p>This event can <strong>only</strong> be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class
or <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> function, and not to individual mappings or
mapped classes.  It is only invoked for all mappings as a whole:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">mapper</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="s2">&quot;after_configured&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">go</span><span class="p">():</span>
    <span class="c1"># ...</span></pre></div>
</div>
<p>Theoretically this event is called once per
application, but is actually called any time new mappers
have been affected by a <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a>
call.   If new mappings are constructed after existing ones have
already been used, this event will likely be called again.  To ensure
that a particular event is only called once and no further, the
<code class="docutils literal"><span class="pre">once=True</span></code> argument (new in 0.9.4) can be applied:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">mapper</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="s2">&quot;after_configured&quot;</span><span class="p">,</span> <span class="n">once</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">go</span><span class="p">():</span>
    <span class="c1"># ...</span></pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="sqlalchemy.orm.events.MapperEvents.before_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.before_configured()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_delete">
<code class="descname">after_delete</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after a DELETE statement
has been emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;after_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_delete</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_delete&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.</p>
<p>The event is often called for a batch of objects of the
same class after their DELETE statements have been emitted at
once in a previous step.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit DELETE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_delete.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_delete.params.target">¶</a> &#8211; the mapped instance being deleted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_insert">
<code class="descname">after_insert</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after an INSERT statement
is emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;after_insert&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_insert</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_insert&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify in-Python-only
state on the instance after an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>The event is often called for a batch of objects of the
same class after their INSERT statements have been
emitted at once in a previous step. In the extremely
rare case that this is not desirable, the
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be configured with <code class="docutils literal"><span class="pre">batch=False</span></code>,
which will cause batches of instances to be broken up
into individual (and more poorly performing)
event-&gt;persist-&gt;event steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit INSERT statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_insert.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_insert.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.after_update">
<code class="descname">after_update</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.after_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after an UPDATE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;after_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_update</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_update&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify in-Python-only
state on the instance after an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>This method is called for all instances that are
marked as &#8220;dirty&#8221;, <em>even those which have no net changes
to their column-based attributes</em>, and for which
no UPDATE statement has proceeded. An object is marked
as dirty when any of its column-based attributes have a
&#8220;set attribute&#8221; operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update" title="sqlalchemy.orm.events.MapperEvents.after_update"><code class="xref py py-meth docutils literal"><span class="pre">after_update()</span></code></a> is
<em>not</em> a guarantee that an UPDATE statement has been
issued.</p>
<p>To detect if the column-based attributes on the object have net
changes, and therefore resulted in an UPDATE statement, use
<code class="docutils literal"><span class="pre">object_session(instance).is_modified(instance,</span>
<span class="pre">include_collections=False)</span></code>.</p>
<p>The event is often called for a batch of objects of the
same class after their UPDATE statements have been emitted at
once in a previous step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit UPDATE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.after_update.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_update.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_configured">
<code class="descname">before_configured</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before a series of mappers have been configured.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;before_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_configured</span><span class="p">():</span>
    <span class="s2">&quot;listen for the &#39;before_configured&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>The <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="sqlalchemy.orm.events.MapperEvents.before_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.before_configured()</span></code></a> event is invoked
each time the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> function is
invoked, before the function has done any of its work.
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.</p>
<p>This event can <strong>only</strong> be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class
or <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> function, and not to individual mappings or
mapped classes.  It is only invoked for all mappings as a whole:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">mapper</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="s2">&quot;before_configured&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">go</span><span class="p">():</span>
    <span class="c1"># ...</span></pre></div>
</div>
<p>Constrast this event to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a>,
which is invoked after the series of mappers has been configured,
as well as <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a>, which is invoked
on a per-mapper basis as each one is configured to the extent possible.</p>
<p>Theoretically this event is called once per
application, but is actually called any time new mappers
are to be affected by a <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a>
call.   If new mappings are constructed after existing ones have
already been used, this event will likely be called again.  To ensure
that a particular event is only called once and no further, the
<code class="docutils literal"><span class="pre">once=True</span></code> argument (new in 0.9.4) can be applied:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">mapper</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="s2">&quot;before_configured&quot;</span><span class="p">,</span> <span class="n">once</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">go</span><span class="p">():</span>
    <span class="c1"># ...</span></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.3.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_delete">
<code class="descname">before_delete</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before a DELETE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;before_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_delete</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_delete&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to emit additional SQL statements on
the given connection as well as to perform application
specific bookkeeping related to a deletion event.</p>
<p>The event is often called for a batch of objects of the
same class before their DELETE statements are emitted at
once in a later step.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit DELETE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_delete.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_delete.params.target">¶</a> &#8211; the mapped instance being deleted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_insert">
<code class="descname">before_insert</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before an INSERT statement
is emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;before_insert&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_insert</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_insert&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify local, non-object related
attributes on the instance before an INSERT occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>The event is often called for a batch of objects of the
same class before their INSERT statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit INSERT statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_insert.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_insert.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.before_update">
<code class="descname">before_update</code><span class="sig-paren">(</span><em>mapper</em>, <em>connection</em>, <em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance before an UPDATE statement
is emitted corresponding to that instance.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;before_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_update</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_update&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is used to modify local, non-object related
attributes on the instance before an UPDATE occurs, as well
as to emit additional SQL statements on the given
connection.</p>
<p>This method is called for all instances that are
marked as &#8220;dirty&#8221;, <em>even those which have no net changes
to their column-based attributes</em>. An object is marked
as dirty when any of its column-based attributes have a
&#8220;set attribute&#8221; operation called or when any of its
collections are modified. If, at update time, no
column-based attributes have any net changes, no UPDATE
statement will be issued. This means that an instance
being sent to <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update" title="sqlalchemy.orm.events.MapperEvents.before_update"><code class="xref py py-meth docutils literal"><span class="pre">before_update()</span></code></a> is
<em>not</em> a guarantee that an UPDATE statement will be
issued, although you can affect the outcome here by
modifying attributes so that a net change in value does
exist.</p>
<p>To detect if the column-based attributes on the object have net
changes, and will therefore generate an UPDATE statement, use
<code class="docutils literal"><span class="pre">object_session(instance).is_modified(instance,</span>
<span class="pre">include_collections=False)</span></code>.</p>
<p>The event is often called for a batch of objects of the
same class before their UPDATE statements are emitted at
once in a later step. In the extremely rare case that
this is not desirable, the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a> can be
configured with <code class="docutils literal"><span class="pre">batch=False</span></code>, which will cause
batches of instances to be broken up into individual
(and more poorly performing) event-&gt;persist-&gt;event
steps.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Mapper-level flush events only allow <strong>very limited operations</strong>,
on attributes local to the row being operated upon only,
as well as allowing any SQL to be emitted on the given
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a>.  <strong>Please read fully</strong> the notes
at <a class="reference internal" href="session_events.html#session-persistence-mapper"><span class="std std-ref">Mapper-level Events</span></a> for guidelines on using
these methods; generally, the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a>
method should be preferred for general on-flush changes.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.connection">¶</a> &#8211; the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> being used to
emit UPDATE statements for this instance.  This
provides a handle into the current transaction on the
target database specific to this instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.before_update.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_update.params.target">¶</a> &#8211; the mapped instance being persisted.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">No return value is supported by this event.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.instrument_class">
<code class="descname">instrument_class</code><span class="sig-paren">(</span><em>mapper</em>, <em>class_</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.instrument_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a class when the mapper is first constructed,
before instrumentation is applied to the mapped class.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;instrument_class&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_instrument_class</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;instrument_class&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is the earliest phase of mapper construction.
Most attributes of the mapper are not yet initialized.</p>
<p>This listener can either be applied to the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a>
class overall, or to any un-mapped class which serves as a base
for classes that will be mapped (using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Base</span> <span class="o">=</span> <span class="n">declarative_base</span><span class="p">()</span>

<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Base</span><span class="p">,</span> <span class="s2">&quot;instrument_class&quot;</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_new_class</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">cls_</span><span class="p">):</span>
    <span class="s2">&quot; ... &quot;</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.instrument_class.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.instrument_class.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.instrument_class.params.class_"></span><strong>class_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.instrument_class.params.class_">¶</a> &#8211; the mapped class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.MapperEvents.mapper_configured">
<code class="descname">mapper_configured</code><span class="sig-paren">(</span><em>mapper</em>, <em>class_</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a specific mapper has completed its own configuration
within the scope of the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">configure_mappers()</span></code></a> call.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;mapper_configured&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_mapper_configured</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">class_</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;mapper_configured&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>The <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a> event is invoked
for each mapper that is encountered when the
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> function proceeds through the current
list of not-yet-configured mappers.
<a class="reference internal" href="mapping_api.html#sqlalchemy.orm.configure_mappers" title="sqlalchemy.orm.configure_mappers"><code class="xref py py-func docutils literal"><span class="pre">orm.configure_mappers()</span></code></a> is typically invoked
automatically as mappings are first used, as well as each time
new mappers have been made available and new mapper use is
detected.</p>
<p>When the event is called, the mapper should be in its final
state, but <strong>not including backrefs</strong> that may be invoked from
other mappers; they might still be pending within the
configuration operation.    Bidirectional relationships that
are instead configured via the
<a class="reference internal" href="relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal"><span class="pre">orm.relationship.back_populates</span></code></a> argument
<em>will</em> be fully available, since this style of relationship does not
rely upon other possibly-not-configured mappers to know that they
exist.</p>
<p>For an event that is guaranteed to have <strong>all</strong> mappers ready
to go including backrefs that are defined only on other
mappings, use the <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a>
event; this event invokes only after all known mappings have been
fully configured.</p>
<p>The <a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured" title="sqlalchemy.orm.events.MapperEvents.mapper_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.mapper_configured()</span></code></a> event, unlike
<a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="sqlalchemy.orm.events.MapperEvents.before_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.before_configured()</span></code></a> or
<a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a>,
is called for each mapper/class individually, and the mapper is
passed to the event itself.  It also is called exactly once for
a particular mapper.  The event is therefore useful for
configurational steps that benefit from being invoked just once
on a specific mapper basis, which don&#8217;t require that &#8220;backref&#8221;
configurations are necessarily ready yet.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.mapper_configured.params.mapper"></span><strong>mapper</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured.params.mapper">¶</a> &#8211; the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> which is the target
of this event.</li>
<li><span class="target" id="sqlalchemy.orm.events.MapperEvents.mapper_configured.params.class_"></span><strong>class_</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.MapperEvents.mapper_configured.params.class_">¶</a> &#8211; the mapped class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.before_configured" title="sqlalchemy.orm.events.MapperEvents.before_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.before_configured()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.MapperEvents.after_configured" title="sqlalchemy.orm.events.MapperEvents.after_configured"><code class="xref py py-meth docutils literal"><span class="pre">MapperEvents.after_configured()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="instance-events">
<h2>Instance Events<a class="headerlink" href="#instance-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.InstanceEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">InstanceEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to object lifecycle.</p>
<p>e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="k">def</span> <span class="nf">my_load_listener</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;on load!&quot;</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">my_load_listener</span><span class="p">)</span></pre></div>
</div>
<p>Available targets include:</p>
<ul class="simple">
<li>mapped classes</li>
<li>unmapped superclasses of mapped or to-be-mapped classes
(using the <code class="docutils literal"><span class="pre">propagate=True</span></code> flag)</li>
<li><a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> objects</li>
<li>the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper.Mapper" title="sqlalchemy.orm.mapper.Mapper"><code class="xref py py-class docutils literal"><span class="pre">Mapper</span></code></a> class itself and the <a class="reference internal" href="mapping_api.html#sqlalchemy.orm.mapper" title="sqlalchemy.orm.mapper"><code class="xref py py-func docutils literal"><span class="pre">mapper()</span></code></a>
function indicate listening for all mappers.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8.0: </span>instance events can be associated with
unmapped superclasses of mapped classes.</p>
</div>
<p>Instance events are closely related to mapper events, but
are more specific to the instance and its instrumentation,
rather than its system of persistence.</p>
<p>When using <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents" title="sqlalchemy.orm.events.InstanceEvents"><code class="xref py py-class docutils literal"><span class="pre">InstanceEvents</span></code></a>, several modifiers are
available to the <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.params.propagate"></span><strong>propagate=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.params.propagate">¶</a> &#8211; When True, the event listener should
be applied to all inheriting classes as well as the
class which is the target of this listener.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.params.raw"></span><strong>raw=False</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.params.raw">¶</a> &#8211; When True, the &#8220;target&#8221; argument passed
to applicable event listener functions will be the
instance&#8217;s <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> management
object, rather than the mapped instance itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.expire">
<code class="descname">expire</code><span class="sig-paren">(</span><em>target</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.expire" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after its attributes or some subset
have been expired.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;expire&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_expire</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;expire&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>&#8216;keys&#8217; is a list of attribute names.  If None, the entire
state was expired.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.expire.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.expire.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.expire.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.expire.params.attrs">¶</a> &#8211; sequence of attribute
names which were expired, or None if all attributes were
expired.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.first_init">
<code class="descname">first_init</code><span class="sig-paren">(</span><em>manager</em>, <em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.first_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the first instance of a particular mapping is called.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;first_init&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_first_init</span><span class="p">(</span><span class="n">manager</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;first_init&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is called when the <code class="docutils literal"><span class="pre">__init__</span></code> method of a class
is called the first time for that particular class.    The event
invokes before <code class="docutils literal"><span class="pre">__init__</span></code> actually proceeds as well as before
the <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init" title="sqlalchemy.orm.events.InstanceEvents.init"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.init()</span></code></a> event is invoked.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.init">
<code class="descname">init</code><span class="sig-paren">(</span><em>target</em>, <em>args</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.init" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an instance when its constructor is called.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;init&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This method is only called during a userland construction of
an object, in conjunction with the object&#8217;s constructor, e.g.
its <code class="docutils literal"><span class="pre">__init__</span></code> method.  It is not called when an object is
loaded from the database; see the <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a>
event in order to intercept a database load.</p>
<p>The event is called before the actual <code class="docutils literal"><span class="pre">__init__</span></code> constructor
of the object is called.  The <code class="docutils literal"><span class="pre">kwargs</span></code> dictionary may be
modified in-place in order to affect what is passed to
<code class="docutils literal"><span class="pre">__init__</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init.params.args"></span><strong>args</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init.params.args">¶</a> &#8211; positional arguments passed to the <code class="docutils literal"><span class="pre">__init__</span></code> method.
This is passed as a tuple and is currently immutable.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init.params.kwargs"></span><strong>kwargs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init.params.kwargs">¶</a> &#8211; keyword arguments passed to the <code class="docutils literal"><span class="pre">__init__</span></code> method.
This structure <em>can</em> be altered in place.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init_failure" title="sqlalchemy.orm.events.InstanceEvents.init_failure"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.init_failure()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.init_failure">
<code class="descname">init_failure</code><span class="sig-paren">(</span><em>target</em>, <em>args</em>, <em>kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.init_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an instance when its constructor has been called,
and raised an exception.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;init_failure&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_init_failure</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;init_failure&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This method is only called during a userland construction of
an object, in conjunction with the object&#8217;s constructor, e.g.
its <code class="docutils literal"><span class="pre">__init__</span></code> method. It is not called when an object is loaded
from the database.</p>
<p>The event is invoked after an exception raised by the <code class="docutils literal"><span class="pre">__init__</span></code>
method is caught.  After the event
is invoked, the original exception is re-raised outwards, so that
the construction of the object still raises an exception.   The
actual exception and stack trace raised should be present in
<code class="docutils literal"><span class="pre">sys.exc_info()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init_failure.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init_failure.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init_failure.params.args"></span><strong>args</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init_failure.params.args">¶</a> &#8211; positional arguments that were passed to the <code class="docutils literal"><span class="pre">__init__</span></code>
method.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.init_failure.params.kwargs"></span><strong>kwargs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init_failure.params.kwargs">¶</a> &#8211; keyword arguments that were passed to the <code class="docutils literal"><span class="pre">__init__</span></code>
method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init" title="sqlalchemy.orm.events.InstanceEvents.init"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.init()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>target</em>, <em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after it has been created via
<code class="docutils literal"><span class="pre">__new__</span></code>, and after initial attribute population has
occurred.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_load</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;load&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This typically occurs when the instance is created based on
incoming result rows, and is only called once for that
instance&#8217;s lifetime.</p>
<p>Note that during a result-row load, this method is called upon
the first row received for this instance.  Note that some
attributes and collections may or may not be loaded or even
initialized, depending on what&#8217;s present in the result rows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.load.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.load.params.context"></span><strong>context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load.params.context">¶</a> &#8211; the <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> corresponding to the
current <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> in progress.  This argument may be
<code class="docutils literal"><span class="pre">None</span></code> if the load does not correspond to a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a>,
such as during <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.merge" title="sqlalchemy.orm.session.Session.merge"><code class="xref py py-meth docutils literal"><span class="pre">Session.merge()</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.init" title="sqlalchemy.orm.events.InstanceEvents.init"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.init()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh" title="sqlalchemy.orm.events.InstanceEvents.refresh"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.refresh()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.loaded_as_persistent" title="sqlalchemy.orm.events.SessionEvents.loaded_as_persistent"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.loaded_as_persistent()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.pickle">
<code class="descname">pickle</code><span class="sig-paren">(</span><em>target</em>, <em>state_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance when its associated state is
being pickled.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;pickle&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_pickle</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;pickle&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.pickle.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.pickle.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.pickle.params.state_dict"></span><strong>state_dict</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.pickle.params.state_dict">¶</a> &#8211; the dictionary returned by
<code class="xref py py-class docutils literal"><span class="pre">InstanceState.__getstate__</span></code>, containing the state
to be pickled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.refresh">
<code class="descname">refresh</code><span class="sig-paren">(</span><em>target</em>, <em>context</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after one or more attributes have
been refreshed from a query.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;refresh&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_refresh</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;refresh&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Contrast this to the <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a> method, which
is invoked when the object is first loaded from a query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.context"></span><strong>context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.context">¶</a> &#8211; the <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> corresponding to the
current <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> in progress.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh.params.attrs">¶</a> &#8211; sequence of attribute names which
were populated, or None if all column-mapped, non-deferred
attributes were populated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.refresh_flush">
<code class="descname">refresh_flush</code><span class="sig-paren">(</span><em>target</em>, <em>flush_context</em>, <em>attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after one or more attributes have
been refreshed within the persistence of the object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;refresh_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_refresh_flush</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;refresh_flush&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is the same as <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh" title="sqlalchemy.orm.events.InstanceEvents.refresh"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.refresh()</span></code></a> except
it is invoked within the unit of work flush process, and the values
here typically come from the process of handling an INSERT or
UPDATE, such as via the RETURNING clause or from Python-side default
values.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.5.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.attrs"></span><strong>attrs</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.refresh_flush.params.attrs">¶</a> &#8211; sequence of attribute names which
were populated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstanceEvents.unpickle">
<code class="descname">unpickle</code><span class="sig-paren">(</span><em>target</em>, <em>state_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstanceEvents.unpickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive an object instance after its associated state has
been unpickled.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="s1">&#39;unpickle&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_unpickle</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;unpickle&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.unpickle.params.target"></span><strong>target</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.unpickle.params.target">¶</a> &#8211; the mapped instance.  If
the event is configured with <code class="docutils literal"><span class="pre">raw=True</span></code>, this will
instead be the <a class="reference internal" href="internals.html#sqlalchemy.orm.state.InstanceState" title="sqlalchemy.orm.state.InstanceState"><code class="xref py py-class docutils literal"><span class="pre">InstanceState</span></code></a> state-management
object associated with the instance.</li>
<li><span class="target" id="sqlalchemy.orm.events.InstanceEvents.unpickle.params.state_dict"></span><strong>state_dict</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.InstanceEvents.unpickle.params.state_dict">¶</a> &#8211; the dictionary sent to
<code class="xref py py-class docutils literal"><span class="pre">InstanceState.__setstate__</span></code>, containing the state
dictionary which was pickled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="session-events">
<h2>Session Events<a class="headerlink" href="#session-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.SessionEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">SessionEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Define events specific to <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> lifecycle.</p>
<p>e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">sessionmaker</span>

<span class="k">def</span> <span class="nf">my_before_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;before commit!&quot;</span>

<span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">()</span>

<span class="n">event</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">Session</span><span class="p">,</span> <span class="s2">&quot;before_commit&quot;</span><span class="p">,</span> <span class="n">my_before_commit</span><span class="p">)</span></pre></div>
</div>
<p>The <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">listen()</span></code></a> function will accept
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> objects as well as the return result
of <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.sessionmaker" title="sqlalchemy.orm.session.sessionmaker"><code class="xref py py-class docutils literal"><span class="pre">sessionmaker()</span></code></a> and <a class="reference internal" href="contextual.html#sqlalchemy.orm.scoping.scoped_session" title="sqlalchemy.orm.scoping.scoped_session"><code class="xref py py-class docutils literal"><span class="pre">scoped_session()</span></code></a>.</p>
<p>Additionally, it accepts the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> class which
will apply listeners to all <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> instances
globally.</p>
<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_attach">
<code class="descname">after_attach</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after an instance is attached to a session.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_attach&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_attach</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_attach&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This is called after an add, delete or merge.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As of 0.8, this event fires off <em>after</em> the item
has been fully associated with the session, which is
different than previous releases.  For event
handlers that require the object not yet
be part of session state (such as handlers which
may autoflush while the target object is not
yet complete) consider the
new <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a> event.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a></p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_begin">
<code class="descname">after_begin</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em>, <em>connection</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a transaction is begun on a connection</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_begin&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_begin</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_begin&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.transaction">¶</a> &#8211; The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_begin.params.connection"></span><strong>connection</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin.params.connection">¶</a> &#8211; The <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection" title="sqlalchemy.engine.Connection"><code class="xref py py-class docutils literal"><span class="pre">Connection</span></code></a> object
which will be used for SQL statements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_bulk_delete">
<code class="descname">after_bulk_delete</code><span class="sig-paren">(</span><em>delete_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a bulk delete operation to the session.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style (arguments as of 0.9)</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_bulk_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_delete</span><span class="p">(</span><span class="n">delete_context</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_bulk_delete&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span>

<span class="c1"># legacy calling style (pre-0.9)</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_bulk_delete&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_delete</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_bulk_delete&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9: </span>The <code class="docutils literal"><span class="pre">after_bulk_delete</span></code> event now accepts the 
arguments <code class="docutils literal"><span class="pre">delete_context</span></code>.
Listener functions which accept the previous argument 
signature(s) listed above will be automatically 
adapted to the new signature.</p>
</div>
<p>This is called as a result of the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.delete" title="sqlalchemy.orm.query.Query.delete"><code class="xref py py-meth docutils literal"><span class="pre">Query.delete()</span></code></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_bulk_delete.params.delete_context"></span><strong>delete_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_delete.params.delete_context">¶</a> &#8211; <p>a &#8220;delete context&#8221; object which contains
details about the update, including these attributes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">session</span></code> - the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> involved</li>
<li><code class="docutils literal"><span class="pre">query</span></code> -the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object that this update operation
was called upon.</li>
<li><code class="docutils literal"><span class="pre">context</span></code> The <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> object, corresponding
to the invocation of an ORM query.</li>
<li><code class="docutils literal"><span class="pre">result</span></code> the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal"><span class="pre">ResultProxy</span></code></a> returned as a result of the
bulk DELETE operation.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_bulk_update">
<code class="descname">after_bulk_update</code><span class="sig-paren">(</span><em>update_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a bulk update operation to the session.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style (arguments as of 0.9)</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_bulk_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_update</span><span class="p">(</span><span class="n">update_context</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_bulk_update&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span>

<span class="c1"># legacy calling style (pre-0.9)</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_bulk_update&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_bulk_update</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">query_context</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_bulk_update&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.9: </span>The <code class="docutils literal"><span class="pre">after_bulk_update</span></code> event now accepts the 
arguments <code class="docutils literal"><span class="pre">update_context</span></code>.
Listener functions which accept the previous argument 
signature(s) listed above will be automatically 
adapted to the new signature.</p>
</div>
<p>This is called as a result of the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query.update" title="sqlalchemy.orm.query.Query.update"><code class="xref py py-meth docutils literal"><span class="pre">Query.update()</span></code></a> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_bulk_update.params.update_context"></span><strong>update_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_bulk_update.params.update_context">¶</a> &#8211; <p>an &#8220;update context&#8221; object which contains
details about the update, including these attributes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">session</span></code> - the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> involved</li>
<li><code class="docutils literal"><span class="pre">query</span></code> -the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object that this update operation
was called upon.</li>
<li><code class="docutils literal"><span class="pre">context</span></code> The <a class="reference internal" href="internals.html#sqlalchemy.orm.query.QueryContext" title="sqlalchemy.orm.query.QueryContext"><code class="xref py py-class docutils literal"><span class="pre">QueryContext</span></code></a> object, corresponding
to the invocation of an ORM query.</li>
<li><code class="docutils literal"><span class="pre">result</span></code> the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ResultProxy" title="sqlalchemy.engine.ResultProxy"><code class="xref py py-class docutils literal"><span class="pre">ResultProxy</span></code></a> returned as a result of the
bulk UPDATE operation.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_commit">
<code class="descname">after_commit</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a commit has occurred.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_commit&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_commit&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a> hook is <em>not</em> per-flush,
that is, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can emit SQL to the database
many times within the scope of a transaction.
For interception of these events, use the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a>, or
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a>
events.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> is not in an active transaction
when the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a> event is invoked,
and therefore can not emit SQL.  To emit SQL corresponding to
every transaction, use the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a>
event.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_commit.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_flush">
<code class="descname">after_flush</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after flush has completed, but before commit has been
called.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_flush</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_flush&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Note that the session&#8217;s state is still in pre-flush, i.e. &#8216;new&#8217;,
&#8216;dirty&#8217;, and &#8216;deleted&#8217; lists still show pre-flush state as well
as the history settings on instance attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a></p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec">
<code class="descname">after_flush_postexec</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after flush has completed, and after the post-exec
state occurs.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_flush_postexec&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_flush_postexec</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_flush_postexec&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This will be when the &#8216;new&#8217;, &#8216;dirty&#8217;, and &#8216;deleted&#8217; lists are in
their final state.  An actual commit() may or may not have
occurred, depending on whether or not the flush started its own
transaction or participated in a larger transaction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a></p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_rollback">
<code class="descname">after_rollback</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after a real DBAPI rollback has occurred.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_rollback&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_rollback</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_rollback&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Note that this event only fires when the <em>actual</em> rollback against
the database occurs - it does <em>not</em> fire each time the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a> method is called, if the underlying
DBAPI transaction has already been rolled back.  In many
cases, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> will not be in
an &#8220;active&#8221; state during this event, as the current
transaction is not valid.   To acquire a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>
which is active after the outermost rollback has proceeded,
use the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback" title="sqlalchemy.orm.events.SessionEvents.after_soft_rollback"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_soft_rollback()</span></code></a> event, checking the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.is_active" title="sqlalchemy.orm.session.Session.is_active"><code class="xref py py-attr docutils literal"><span class="pre">Session.is_active</span></code></a> flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_rollback.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_rollback.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback">
<code class="descname">after_soft_rollback</code><span class="sig-paren">(</span><em>session</em>, <em>previous_transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute after any rollback has occurred, including &#8220;soft&#8221;
rollbacks that don&#8217;t actually emit at the DBAPI level.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_soft_rollback&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_soft_rollback</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">previous_transaction</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_soft_rollback&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This corresponds to both nested and outer rollbacks, i.e.
the innermost rollback that calls the DBAPI&#8217;s
rollback() method, as well as the enclosing rollback
calls that only pop themselves from the transaction stack.</p>
<p>The given <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can be used to invoke SQL and
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.query" title="sqlalchemy.orm.session.Session.query"><code class="xref py py-meth docutils literal"><span class="pre">Session.query()</span></code></a> operations after an outermost rollback
by first checking the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.is_active" title="sqlalchemy.orm.session.Session.is_active"><code class="xref py py-attr docutils literal"><span class="pre">Session.is_active</span></code></a> flag:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Session</span><span class="p">,</span> <span class="s2">&quot;after_soft_rollback&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">previous_transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
        <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;select * from some_table&quot;</span><span class="p">)</span></pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.previous_transaction"></span><strong>previous_transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_soft_rollback.params.previous_transaction">¶</a> &#8211; The <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
transactional marker object which was just closed.   The current
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> for the given <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> is
available via the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.transaction" title="sqlalchemy.orm.session.Session.transaction"><code class="xref py py-attr docutils literal"><span class="pre">Session.transaction</span></code></a> attribute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.7.3.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_transaction_create">
<code class="descname">after_transaction_create</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute when a new <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> is created.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_transaction_create&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_transaction_create</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_transaction_create&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event differs from <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a>
in that it occurs for each <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
overall, as opposed to when transactions are begun
on individual database connections.  It is also invoked
for nested transactions and subtransactions, and is always
matched by a corresponding
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a> event
(assuming normal operation of the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.session">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create.params.transaction">¶</a> &#8211; <p>the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</p>
<p>To detect if this is the outermost
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>, as opposed to a &#8220;subtransaction&#8221; or a
SAVEPOINT, test that the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction.parent" title="sqlalchemy.orm.session.SessionTransaction.parent"><code class="xref py py-attr docutils literal"><span class="pre">SessionTransaction.parent</span></code></a> attribute
is <code class="docutils literal"><span class="pre">None</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;after_transaction_create&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">after_transaction_create</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># work with top-level transaction</span></pre></div>
</div>
<p>To detect if the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> is a SAVEPOINT, use the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction.nested" title="sqlalchemy.orm.session.SessionTransaction.nested"><code class="xref py py-attr docutils literal"><span class="pre">SessionTransaction.nested</span></code></a> attribute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;after_transaction_create&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">after_transaction_create</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
        <span class="c1"># work with SAVEPOINT transaction</span></pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.after_transaction_end">
<code class="descname">after_transaction_end</code><span class="sig-paren">(</span><em>session</em>, <em>transaction</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute when the span of a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> ends.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;after_transaction_end&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_after_transaction_end</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;after_transaction_end&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event differs from <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a>
in that it corresponds to all <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>
objects in use, including those for nested transactions
and subtransactions, and is always matched by a corresponding
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a> event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.session">¶</a> &#8211; the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.transaction"></span><strong>transaction</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end.params.transaction">¶</a> &#8211; <p>the target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>.</p>
<p>To detect if this is the outermost
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a>, as opposed to a &#8220;subtransaction&#8221; or a
SAVEPOINT, test that the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction.parent" title="sqlalchemy.orm.session.SessionTransaction.parent"><code class="xref py py-attr docutils literal"><span class="pre">SessionTransaction.parent</span></code></a> attribute
is <code class="docutils literal"><span class="pre">None</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;after_transaction_create&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">after_transaction_end</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># work with top-level transaction</span></pre></div>
</div>
<p>To detect if the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a> is a SAVEPOINT, use the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction.nested" title="sqlalchemy.orm.session.SessionTransaction.nested"><code class="xref py py-attr docutils literal"><span class="pre">SessionTransaction.nested</span></code></a> attribute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s2">&quot;after_transaction_create&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">after_transaction_end</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">transaction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
        <span class="c1"># work with SAVEPOINT transaction</span></pre></div>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="session_api.html#sqlalchemy.orm.session.SessionTransaction" title="sqlalchemy.orm.session.SessionTransaction"><code class="xref py py-class docutils literal"><span class="pre">SessionTransaction</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_attach">
<code class="descname">before_attach</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before an instance is attached to a session.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;before_attach&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_attach</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_attach&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This is called before an add, delete or merge causes
the object to be part of the session.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.8.: </span>Note that <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">after_attach()</span></code></a>
now fires off after the item is part of the session.
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_attach" title="sqlalchemy.orm.events.SessionEvents.before_attach"><code class="xref py py-meth docutils literal"><span class="pre">before_attach()</span></code></a> is provided for those cases where
the item should not yet be part of the session state.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">after_attach()</span></code></a></p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_commit">
<code class="descname">before_commit</code><span class="sig-paren">(</span><em>session</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before commit is called.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;before_commit&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_commit</span><span class="p">(</span><span class="n">session</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_commit&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit" title="sqlalchemy.orm.events.SessionEvents.before_commit"><code class="xref py py-meth docutils literal"><span class="pre">before_commit()</span></code></a> hook is <em>not</em> per-flush,
that is, the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> can emit SQL to the database
many times within the scope of a transaction.
For interception of these events, use the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">before_flush()</span></code></a>,
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a>, or
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a>
events.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_commit.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_commit.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_commit" title="sqlalchemy.orm.events.SessionEvents.after_commit"><code class="xref py py-meth docutils literal"><span class="pre">after_commit()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_begin" title="sqlalchemy.orm.events.SessionEvents.after_begin"><code class="xref py py-meth docutils literal"><span class="pre">after_begin()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_create" title="sqlalchemy.orm.events.SessionEvents.after_transaction_create"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_create()</span></code></a></p>
<p class="last"><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_transaction_end" title="sqlalchemy.orm.events.SessionEvents.after_transaction_end"><code class="xref py py-meth docutils literal"><span class="pre">after_transaction_end()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.before_flush">
<code class="descname">before_flush</code><span class="sig-paren">(</span><em>session</em>, <em>flush_context</em>, <em>instances</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute before flush process has started.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;before_flush&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_flush</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_flush&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.session">¶</a> &#8211; The target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a>.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.flush_context"></span><strong>flush_context</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.flush_context">¶</a> &#8211; Internal <a class="reference internal" href="internals.html#sqlalchemy.orm.session.UOWTransaction" title="sqlalchemy.orm.session.UOWTransaction"><code class="xref py py-class docutils literal"><span class="pre">UOWTransaction</span></code></a> object
which handles the details of the flush.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.before_flush.params.instances"></span><strong>instances</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush.params.instances">¶</a> &#8211; Usually <code class="docutils literal"><span class="pre">None</span></code>, this is the collection of
objects which can be passed to the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.flush" title="sqlalchemy.orm.session.Session.flush"><code class="xref py py-meth docutils literal"><span class="pre">Session.flush()</span></code></a> method
(note this usage is deprecated).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">after_flush()</span></code></a></p>
<p><a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush_postexec" title="sqlalchemy.orm.events.SessionEvents.after_flush_postexec"><code class="xref py py-meth docutils literal"><span class="pre">after_flush_postexec()</span></code></a></p>
<p class="last"><a class="reference internal" href="session_events.html#session-persistence-events"><span class="std std-ref">Persistence Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.deleted_to_detached">
<code class="descname">deleted_to_detached</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.deleted_to_detached" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;deleted to detached&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;deleted_to_detached&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_deleted_to_detached</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;deleted_to_detached&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked when a deleted object is evicted
from the session.   The typical case when this occurs is when
the transaction for a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> in which the object
was deleted is committed; the object moves from the deleted
state to the detached state.</p>
<p>It is also invoked for objects that were deleted in a flush
when the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.expunge_all" title="sqlalchemy.orm.session.Session.expunge_all"><code class="xref py py-meth docutils literal"><span class="pre">Session.expunge_all()</span></code></a> or <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.close" title="sqlalchemy.orm.session.Session.close"><code class="xref py py-meth docutils literal"><span class="pre">Session.close()</span></code></a>
events are called, as well as if the object is individually
expunged from its deleted state via <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.expunge" title="sqlalchemy.orm.session.Session.expunge"><code class="xref py py-meth docutils literal"><span class="pre">Session.expunge()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.deleted_to_persistent">
<code class="descname">deleted_to_persistent</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.deleted_to_persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;deleted to persistent&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;deleted_to_persistent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_deleted_to_persistent</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;deleted_to_persistent&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This transition occurs only when an object that&#8217;s been deleted
successfully in a flush is restored due to a call to
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a>.   The event is not called under
any other circumstances.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.detached_to_persistent">
<code class="descname">detached_to_persistent</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.detached_to_persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;detached to persistent&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;detached_to_persistent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_detached_to_persistent</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;detached_to_persistent&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is a specialization of the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_attach()</span></code></a> event which is only invoked
for this specific transition.  It is invoked typically during the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a> call, as well as during the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a> call if the object was not previously
associated with the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> (note that an object marked as &#8220;deleted&#8221; remains
in the &#8220;persistent&#8221; state until the flush proceeds).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the object becomes persistent as part of a call to
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a>, the object is <strong>not</strong> yet marked as
deleted when this event is called.  To detect deleted objects,
check the <code class="docutils literal"><span class="pre">deleted</span></code> flag sent to the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_detached" title="sqlalchemy.orm.events.SessionEvents.persistent_to_detached"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.persistent_to_detached()</span></code></a> to event after the
flush proceeds, or check the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.deleted" title="sqlalchemy.orm.session.Session.deleted"><code class="xref py py-attr docutils literal"><span class="pre">Session.deleted</span></code></a> collection
within the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.before_flush" title="sqlalchemy.orm.events.SessionEvents.before_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.before_flush()</span></code></a> event if deleted
objects need to be intercepted before the flush.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.detached_to_persistent.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.detached_to_persistent.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.detached_to_persistent.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.detached_to_persistent.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.loaded_as_persistent">
<code class="descname">loaded_as_persistent</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.loaded_as_persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;loaded as persistent&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;loaded_as_persistent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_loaded_as_persistent</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;loaded_as_persistent&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked within the ORM loading process, and is invoked
very similarly to the <a class="reference internal" href="#sqlalchemy.orm.events.InstanceEvents.load" title="sqlalchemy.orm.events.InstanceEvents.load"><code class="xref py py-meth docutils literal"><span class="pre">InstanceEvents.load()</span></code></a> event.  However,
the event here is linkable to a <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> class or instance,
rather than to a mapper or class hierarchy, and integrates
with the other session lifecycle events smoothly.  The object
is guaranteed to be present in the session&#8217;s identity map when
this event is called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.loaded_as_persistent.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.loaded_as_persistent.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.loaded_as_persistent.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.loaded_as_persistent.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.pending_to_persistent">
<code class="descname">pending_to_persistent</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.pending_to_persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;pending to persistent&#8221;&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;pending_to_persistent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_pending_to_persistent</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;pending_to_persistent&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked within the flush process, and is
similar to scanning the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.new" title="sqlalchemy.orm.session.Session.new"><code class="xref py py-attr docutils literal"><span class="pre">Session.new</span></code></a> collection within
the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_flush" title="sqlalchemy.orm.events.SessionEvents.after_flush"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_flush()</span></code></a> event.  However, in this
case the object has already been moved to the persistent state
when the event is called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.pending_to_persistent.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.pending_to_persistent.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.pending_to_persistent.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.pending_to_persistent.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.pending_to_transient">
<code class="descname">pending_to_transient</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.pending_to_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;pending to transient&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;pending_to_transient&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_pending_to_transient</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;pending_to_transient&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This less common transition occurs when an pending object that has
not been flushed is evicted from the session; this can occur
when the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a> method rolls back the transaction,
or when the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.expunge" title="sqlalchemy.orm.session.Session.expunge"><code class="xref py py-meth docutils literal"><span class="pre">Session.expunge()</span></code></a> method is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.pending_to_transient.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.pending_to_transient.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.pending_to_transient.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.pending_to_transient.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.persistent_to_deleted">
<code class="descname">persistent_to_deleted</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_deleted" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;persistent to deleted&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;persistent_to_deleted&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_persistent_to_deleted</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;persistent_to_deleted&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked when a persistent object&#8217;s identity
is deleted from the database within a flush, however the object
still remains associated with the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a> until the
transaction completes.</p>
<p>If the transaction is rolled back, the object moves again
to the persistent state, and the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.deleted_to_persistent" title="sqlalchemy.orm.events.SessionEvents.deleted_to_persistent"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.deleted_to_persistent()</span></code></a> event is called.
If the transaction is committed, the object becomes detached,
which will emit the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.deleted_to_detached" title="sqlalchemy.orm.events.SessionEvents.deleted_to_detached"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.deleted_to_detached()</span></code></a>
event.</p>
<p>Note that while the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.delete" title="sqlalchemy.orm.session.Session.delete"><code class="xref py py-meth docutils literal"><span class="pre">Session.delete()</span></code></a> method is the primary
public interface to mark an object as deleted, many objects
get deleted due to cascade rules, which are not always determined
until flush time.  Therefore, there&#8217;s no way to catch
every object that will be deleted until the flush has proceeded.
the <a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_deleted" title="sqlalchemy.orm.events.SessionEvents.persistent_to_deleted"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.persistent_to_deleted()</span></code></a> event is therefore
invoked at the end of a flush.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.persistent_to_detached">
<code class="descname">persistent_to_detached</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_detached" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;persistent to detached&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;persistent_to_detached&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_persistent_to_detached</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;persistent_to_detached&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is invoked when a persistent object is evicted
from the session.  There are many conditions that cause this
to happen, including:</p>
<ul class="simple">
<li>using a method such as <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.expunge" title="sqlalchemy.orm.session.Session.expunge"><code class="xref py py-meth docutils literal"><span class="pre">Session.expunge()</span></code></a>
or <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.close" title="sqlalchemy.orm.session.Session.close"><code class="xref py py-meth docutils literal"><span class="pre">Session.close()</span></code></a></li>
<li>Calling the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a> method, when the object
was part of an INSERT statement for that session&#8217;s transaction</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.deleted"></span><strong>deleted</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_detached.params.deleted">¶</a> &#8211; boolean.  If True, indicates this object moved
to the detached state because it was marked as deleted and flushed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.persistent_to_transient">
<code class="descname">persistent_to_transient</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;persistent to transient&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;persistent_to_transient&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_persistent_to_transient</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;persistent_to_transient&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This less common transition occurs when an pending object that has
has been flushed is evicted from the session; this can occur
when the <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.rollback" title="sqlalchemy.orm.session.Session.rollback"><code class="xref py py-meth docutils literal"><span class="pre">Session.rollback()</span></code></a> method rolls back the transaction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.persistent_to_transient.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_transient.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.persistent_to_transient.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.persistent_to_transient.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.SessionEvents.transient_to_pending">
<code class="descname">transient_to_pending</code><span class="sig-paren">(</span><em>session</em>, <em>instance</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.SessionEvents.transient_to_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Intercept the &#8220;transient to pending&#8221; transition for a specific object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeSessionOrFactory</span><span class="p">,</span> <span class="s1">&#39;transient_to_pending&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_transient_to_pending</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;transient_to_pending&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is a specialization of the
<a class="reference internal" href="#sqlalchemy.orm.events.SessionEvents.after_attach" title="sqlalchemy.orm.events.SessionEvents.after_attach"><code class="xref py py-meth docutils literal"><span class="pre">SessionEvents.after_attach()</span></code></a> event which is only invoked
for this specific transition.  It is invoked typically during the
<a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session.add" title="sqlalchemy.orm.session.Session.add"><code class="xref py py-meth docutils literal"><span class="pre">Session.add()</span></code></a> call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.transient_to_pending.params.session"></span><strong>session</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.transient_to_pending.params.session">¶</a> &#8211; target <a class="reference internal" href="session_api.html#sqlalchemy.orm.session.Session" title="sqlalchemy.orm.session.Session"><code class="xref py py-class docutils literal"><span class="pre">Session</span></code></a></li>
<li><span class="target" id="sqlalchemy.orm.events.SessionEvents.transient_to_pending.params.instance"></span><strong>instance</strong><a class="paramlink headerlink reference internal" href="#sqlalchemy.orm.events.SessionEvents.transient_to_pending.params.instance">¶</a> &#8211; the ORM-mapped instance being operated upon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.1.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="session_events.html#session-lifecycle-events"><span class="std std-ref">Object Lifecycle Events</span></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="query-events">
<h2>Query Events<a class="headerlink" href="#query-events" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sqlalchemy.orm.events.QueryEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">QueryEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.QueryEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Represent events within the construction of a <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object.</p>
<p>The events here are intended to be used with an as-yet-unreleased
inspection system for <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a>.   Some very basic operations
are possible now, however the inspection system is intended to allow
complex query manipulations to be automated.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.0.</span></p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.events.QueryEvents.before_compile">
<code class="descname">before_compile</code><span class="sig-paren">(</span><em>query</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.QueryEvents.before_compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive the <a class="reference internal" href="query.html#sqlalchemy.orm.query.Query" title="sqlalchemy.orm.query.Query"><code class="xref py py-class docutils literal"><span class="pre">Query</span></code></a> object before it is composed into a
core <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal"><span class="pre">Select</span></code></a> object.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeQuery</span><span class="p">,</span> <span class="s1">&#39;before_compile&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_before_compile</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;before_compile&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>This event is intended to allow changes to the query given:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">Query</span><span class="p">,</span> <span class="s2">&quot;before_compile&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_deleted</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">column_descriptions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="n">User</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s1">&#39;entity&#39;</span><span class="p">]</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entity</span><span class="o">.</span><span class="n">deleted</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">query</span></pre></div>
</div>
<p>The event should normally be listened with the <code class="docutils literal"><span class="pre">retval=True</span></code>
parameter set, so that the modified query may be returned.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sqlalchemy.orm.instrumentation">
<span id="instrumentation-events"></span><h2>Instrumentation Events<a class="headerlink" href="#module-sqlalchemy.orm.instrumentation" title="Permalink to this headline">¶</a></h2>
<p>Defines SQLAlchemy&#8217;s system of class instrumentation.</p>
<p>This module is usually not directly visible to user applications, but
defines a large part of the ORM&#8217;s interactivity.</p>
<p>instrumentation.py deals with registration of end-user classes
for state tracking.   It interacts closely with state.py
and attributes.py which establish per-instance and per-class-attribute
instrumentation, respectively.</p>
<p>The class instrumentation system can be customized on a per-class
or global basis using the <a class="reference internal" href="extensions/instrumentation.html#module-sqlalchemy.ext.instrumentation" title="sqlalchemy.ext.instrumentation"><code class="xref py py-mod docutils literal"><span class="pre">sqlalchemy.ext.instrumentation</span></code></a>
module, which provides the means to build and specify
alternate instrumentation forms.</p>
<dl class="class">
<dt id="sqlalchemy.orm.events.InstrumentationEvents">
<em class="property">class </em><code class="descclassname">sqlalchemy.orm.events.</code><code class="descname">InstrumentationEvents</code><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../core/events.html#sqlalchemy.event.base.Events" title="sqlalchemy.event.base.Events"><code class="xref py py-class docutils literal"><span class="pre">sqlalchemy.event.base.Events</span></code></a></p>
<p>Events related to class instrumentation events.</p>
<p>The listeners here support being established against
any new style class, that is any object that is a subclass
of &#8216;type&#8217;.  Events will then be fired off for events
against that class.  If the &#8220;propagate=True&#8221; flag is passed
to event.listen(), the event will fire off for subclasses
of that class as well.</p>
<p>The Python <code class="docutils literal"><span class="pre">type</span></code> builtin is also accepted as a target,
which when used has the effect of events being emitted
for all classes.</p>
<p>Note the &#8220;propagate&#8221; flag here is defaulted to <code class="docutils literal"><span class="pre">True</span></code>,
unlike the other class level events where it defaults
to <code class="docutils literal"><span class="pre">False</span></code>.  This means that new subclasses will also
be the subject of these events, when a listener
is established on a superclass.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.8: </span>- events here will emit based
on comparing the incoming class to the type of class
passed to <a class="reference internal" href="../core/event.html#sqlalchemy.event.listen" title="sqlalchemy.event.listen"><code class="xref py py-func docutils literal"><span class="pre">event.listen()</span></code></a>.  Previously, the
event would fire for any class unconditionally regardless
of what class was sent for listening, despite
documentation which stated the contrary.</p>
</div>
<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument">
<code class="descname">attribute_instrument</code><span class="sig-paren">(</span><em>cls</em>, <em>key</em>, <em>inst</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument" title="Permalink to this definition">¶</a></dt>
<dd><div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s1">&#39;attribute_instrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_attribute_instrument</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;attribute_instrument&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>Called when an attribute is instrumented.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.class_instrument">
<code class="descname">class_instrument</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.class_instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after the given class is instrumented.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s1">&#39;class_instrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_class_instrument</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;class_instrument&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>To get at the <a class="reference internal" href="internals.html#sqlalchemy.orm.instrumentation.ClassManager" title="sqlalchemy.orm.instrumentation.ClassManager"><code class="xref py py-class docutils literal"><span class="pre">ClassManager</span></code></a>, use
<code class="xref py py-func docutils literal"><span class="pre">manager_of_class()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument">
<code class="descname">class_uninstrument</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the given class is uninstrumented.</p>
<div class="event-signatures docutils container">
<p>Example argument forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">event</span>

<span class="c1"># standard decorator style</span>
<span class="nd">@event</span><span class="o">.</span><span class="n">listens_for</span><span class="p">(</span><span class="n">SomeBaseClass</span><span class="p">,</span> <span class="s1">&#39;class_uninstrument&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">receive_class_uninstrument</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="s2">&quot;listen for the &#39;class_uninstrument&#39; event&quot;</span>

    <span class="c1"># ... (event handling logic) ...</span></pre></div>
</div>
</div>
<p>To get at the <a class="reference internal" href="internals.html#sqlalchemy.orm.instrumentation.ClassManager" title="sqlalchemy.orm.instrumentation.ClassManager"><code class="xref py py-class docutils literal"><span class="pre">ClassManager</span></code></a>, use
<code class="xref py py-func docutils literal"><span class="pre">manager_of_class()</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="extending.html" title="previous chapter">Events and Internals</a>
        Next:
        <a href="internals.html" title="next chapter">ORM Internals</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2017, the SQLAlchemy authors and contributors.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5.3.
    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.1.9',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/detectmobile.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


